#编程 #CSharp
## 一、操作符预览

- 操作符(Operator)也被译为"运算符"
- 操作符是用来操作数据的，被操作符操作的数据称为操作数(Operand)

C# 提供了许多运算符。 其中许多都受到内置类型的支持，可用于对这些类型的值执行基本操作。 这些运算符包括以下组：
- 算术运算符，将对数值操作数执行算术运算
- 比较运算符，将比较数值操作数
- 布尔逻辑运算符，将对 bool 操作数执行逻辑运算
- 位运算符和移位运算符，将对整数类型的操作数执行位运算或移位运算
- 相等运算符，将检查其操作数是否相等
- 通常可以重载这些运算符，也就是说，可以为用户定义类型的操作数指定运算符行为。

最简单的 C# 表达式是文本（例如整数和实数）和变量名称。 可以使用运算符将它们组合成复杂的表达式。 运算符优先级和结合性决定了表达式中操作的执行顺序。 可以使用括号更改由运算符优先级和结合性决定的计算顺序。

## 二、操作符的本质

- 操作符的本质就是函数(即算法)的“简记法”
    - 如果没有发明“+”、只有Add()函数，算式`3+4+5`将只可以写成`Add(Add(3,4), 5)`
    - 如果没有发明“x”、只有Mul函数、那么算式`3+4*5`只能写成`Add(3, Mul(4, 5))`
- 操作符不能脱离与它关联的数据类型(比如double数据类型的除法与int类型的除法相同数据结果不同)
  - 可以说操作符就是与固定数据相关联的一套基本算法的简记法。
  - 示例：为自定义的数据类型创建操作符。(格式为把方法名字改为”operator  想要定义的操作符”如：”operator +”)如下例子进一步说明了C#里面的操作符就是方法，也就是函数的一个简记法。

## 三、优先级与运算顺序

当运算符的优先级相同，运算符的结合性决定了运算的执行顺序：

- 左结合运算符按从左到右的顺序计算。 除赋值运算符和 null 合并运算符外，所有二元运算符都是左结合运算符。 例如，a + b - c 将计算为 (a + b) - c。
- 右结合运算符按从右到左的顺序计算。 赋值运算符、null 合并运算符、lambda 和条件运算符?:是右结合运算符。 例如，x = y = z 将计算为 x = (y = z)。

![](http://localhost:5244/d/%E7%BB%88%E7%AB%AF%E4%BA%91%E7%9B%98/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/Images/%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%A2%84%E8%A7%88.png)

## 四、运算符详解

### 1. 算术运算符

通过对元素操作的个数可以将算术运算符分为一元和二元：
- 一元：++(自增)、--(自减)
- 二元： *(乘法)、/(除法)、%(余数)、+(加)、-(减)

#### 1.1 自增运算符 ++

##### 1.1.1 前缀自增运算符

前缀自增运算符(即++x;)是指"先加1，后使用"。

```C#
int num1 = 1;
++num1;
Console.WriteLine(num1); // 2
int num2 = ++num1;
Console.WriteLine(num1); // 3
Console.WriteLine(num2); // 3
```

前++是先自增1，再操作。`int num2 = ++num1;`num1先加1在赋值，即：

```C#
num1 += 1; num2 = num1;
```

##### 1.1.2 后缀自增运算符

后缀自增运算符(即x++;)与前++不同的是后加加"先使用，后加1"。

```C#
int num1 = 1;
num1++;
Console.WriteLine(num1); // 2
int num2 = num1++;
Console.WriteLine(num1); // 2
Console.WriteLine(num2); // 3
```

我们可以看到num1经过后++操作后自增1变为3，但是被赋值的变量num2却还是2，这是因为后++是先操作后加1，即：

```C#
num2 = num1; num1 += 1;
```

##### 1.1.3 总结

前++和后++唯一的区别就是先操作还是先加1，你只需要记住++在前就是先加1，++在后就是先操作，无论是什么操作符都是如此。

> 提示：自增运算符（++）适用于数值和枚举类型。

自减运算符同理

#### 1.2 二元运算符

二元运算符，即+(加)、-(减)、*(乘)、\\(除)、%(取模)，与数学运算相同，就不过多赘述了。

这里值得注意的一点是运算符并不会改变值的数据类型，例如 `10 / 3` 在数学中应该是3.33，但是在C#中应该是3。

```C#
Console.WriteLine(10 / 3); // 3
```

因为10的数据类型int，而3的数据类型也是int，int与int经过运算符操作后还是int，所以是3。如果你想输出3.33的话，你可以将10(int)改为10.00(double)或者将3(int)改为3.00(double)，在运算时如果两个数据的类型不相同，则会将精度小的数据转换为精度大的数据，再进行运算。

但是有一点需要注意：

```C#
Console.WriteLine((double)(10/3));
```

这种表达方式是不对的，因为10/3为3，而将3(int)装换为double为3.00而不是3.33。

##### 1.2.1 深入了解+

前面我们说+(加号) 不仅可以进行同类型运算，还可以进行不同精度数据运算。 

先将精度小的变量转换为精度大的变量，再进行运算。顺梯度转换 (隐式转换) 不会导致数据溢出，所以我们也可以利用+来改变字符或字符串。

#### 1.3 复合赋值

举个简单例子：`i += 1`相当于`i = i + 1`，其他同理。

### 2. 逻辑运算符

逻辑运算符包括一下几类：
- 一元 ：!(逻辑非)
- 二元： &(逻辑与)、|(逻辑或)和 ^(逻辑异或)，此类运算符会就算两个操作数
- 二元： &&(条件逻辑与) 和 ||(条件逻辑或)，非必要情况下只运算一个操作数

#### 2.1 逻辑非 !

逻辑非就是取bool的反值。例如judge为true，则!judge为false。

#### 2.2 逻辑与运算符 &

逻辑与两边的都为ture，则为true，如果有一个及以上false的话则为false。


```C#
bool judge1 = true;
bool judge2 = false;

Console.WriteLine(judge1 & judge1); // true
Console.WriteLine(judge1 & judge2); // false
Console.WriteLine(judge2 & judge2); // false
```

这里注意一个细节，逻辑与会判断两边是否正确，进行判断。例如:

```C#
int i = 1;
bool judge = false & i++<1;
Console.WriteLine(judge); // false
Console.WriteLine(i); // 2
```

#### 2.3 逻辑异或运算符 ^

逻辑异或相当于取逻辑与的反值，即：

```C#
bool judge1 = true;
bool judge2 = false;

Console.WriteLine(judge1 ^ judge1); // false
Console.WriteLine(judge1 ^ judge2); // true
Console.WriteLine(judge2 ^ judge2); // true
```

#### 2.4 逻辑或运算符 |

逻辑与与逻辑或不同的是逻辑与只要有一个为true则为true。

```C#
bool judge1 = true;
bool judge2 = false;

Console.WriteLine(judge1 & judge1); // true
Console.WriteLine(judge1 & judge2); // true
Console.WriteLine(judge2 & judge2); // false
```

#### 2.5 条件逻辑运算符

条件逻辑与运算符和条件逻辑或运算符与逻辑运算符大体相同，但是有一个细节，条件逻辑运算符如果执行第一个为false则不会继续执行，例如：

```C#
int i = 1;
bool judge = false && i++<1;
Console.WriteLine(judge); // false
Console.WriteLine(i); // 1
```

由于判断结果一样，且条件逻辑运算符更加简便，所以我们通常情况下都使用条件逻辑运算符。

### 3. 比较运算符

<(小于)、>(大于)、<=(小于或等于)和 >=(大于或等于)比较(也称为关系)运算符比较其操作数。 所有整型和浮点数值类型都支持这些运算符。

其运行结果为bool类型。

### 4. 相等运算

`==`（相等） 和 !=（不等） 运算符检查其操作数是否相等。 当内容相等时，值类型相等。 当两个变量引用同一存储时，引用类型相等。

> [!quote] **注意** 
> `=` 不是相等运算符而是赋值运算符，它的本质是赋值而不是判断。
### 5. 其他运算符

| 运算符    | 描述                                 | 示例                                                |
| --------- | ------------------------------------ | --------------------------------------------------- |
| sizeof () | 返回数据类型的大小                   | sizeof (int)，将返回 4                              |
| typeof () | 返回 class 的类型                    | typeof (StreamReader);                              |
| &         | 返回变量地址                         | &a; 将得到变量的实际地址                            |
| *         | 变量的指针                           | `*a;` 将指向一个变量                                |
| ?:        | 条件表达式                           | 如果条件为真? 则为 X：则为Y                         |
| is        | 判断对象是否为某一类型               | if (Ford is Car) // 检查 Ford 是否是 Car 的一个对象 |
| as        | 强制转换，即使转换失败也不会抛出异常 |     Object obj = new StringReader ("Hello");  StringReader r = obj as StringReader;

这些运算符我们会着重放在后面讲解，有印象即可。